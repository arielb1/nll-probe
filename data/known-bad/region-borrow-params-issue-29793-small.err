{"message":"`x` does not live long enough (Ast)","code":{"code":"E0597","explanation":"\nThis error occurs because a borrow was made inside a variable which has a\ngreater lifetime than the borrowed one.\n\nExample of erroneous code:\n\n```compile_fail,E0597\nstruct Foo<'a> {\n    x: Option<&'a u32>,\n}\n\nlet mut x = Foo { x: None };\nlet y = 0;\nx.x = Some(&y); // error: `y` does not live long enough\n```\n\nIn here, `x` is created before `y` and therefore has a greater lifetime. Always\nkeep in mind that values in a scope are dropped in the opposite order they are\ncreated. So to fix the previous example, just make the `y` lifetime greater than\nthe `x`'s one:\n\n```\nstruct Foo<'a> {\n    x: Option<&'a u32>,\n}\n\nlet y = 0;\nlet mut x = Foo { x: None };\nx.x = Some(&y);\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":717,"byte_end":726,"line_start":19,"line_end":19,"column_start":17,"column_end":26,"is_primary":false,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":17,"highlight_end":26}],"label":"capture occurs here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":734,"byte_end":735,"line_start":19,"line_end":19,"column_start":34,"column_end":35,"is_primary":true,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":34,"highlight_end":35}],"label":"does not live long enough","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":1244,"byte_end":1245,"line_start":29,"line_end":29,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    };","highlight_start":5,"highlight_end":6}],"label":"borrowed value dropped before borrower","suggested_replacement":null,"expansion":null}],"children":[{"message":"values in a scope are dropped in the opposite order they are created","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":null}
{"message":"`y` does not live long enough (Ast)","code":{"code":"E0597","explanation":"\nThis error occurs because a borrow was made inside a variable which has a\ngreater lifetime than the borrowed one.\n\nExample of erroneous code:\n\n```compile_fail,E0597\nstruct Foo<'a> {\n    x: Option<&'a u32>,\n}\n\nlet mut x = Foo { x: None };\nlet y = 0;\nx.x = Some(&y); // error: `y` does not live long enough\n```\n\nIn here, `x` is created before `y` and therefore has a greater lifetime. Always\nkeep in mind that values in a scope are dropped in the opposite order they are\ncreated. So to fix the previous example, just make the `y` lifetime greater than\nthe `x`'s one:\n\n```\nstruct Foo<'a> {\n    x: Option<&'a u32>,\n}\n\nlet y = 0;\nlet mut x = Foo { x: None };\nx.x = Some(&y);\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":717,"byte_end":726,"line_start":19,"line_end":19,"column_start":17,"column_end":26,"is_primary":false,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":17,"highlight_end":26}],"label":"capture occurs here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":745,"byte_end":746,"line_start":19,"line_end":19,"column_start":45,"column_end":46,"is_primary":true,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":45,"highlight_end":46}],"label":"does not live long enough","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":1244,"byte_end":1245,"line_start":29,"line_end":29,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    };","highlight_start":5,"highlight_end":6}],"label":"borrowed value dropped before borrower","suggested_replacement":null,"expansion":null}],"children":[{"message":"values in a scope are dropped in the opposite order they are created","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":null}
{"message":"`x` does not live long enough (Ast)","code":{"code":"E0597","explanation":"\nThis error occurs because a borrow was made inside a variable which has a\ngreater lifetime than the borrowed one.\n\nExample of erroneous code:\n\n```compile_fail,E0597\nstruct Foo<'a> {\n    x: Option<&'a u32>,\n}\n\nlet mut x = Foo { x: None };\nlet y = 0;\nx.x = Some(&y); // error: `y` does not live long enough\n```\n\nIn here, `x` is created before `y` and therefore has a greater lifetime. Always\nkeep in mind that values in a scope are dropped in the opposite order they are\ncreated. So to fix the previous example, just make the `y` lifetime greater than\nthe `x`'s one:\n\n```\nstruct Foo<'a> {\n    x: Option<&'a u32>,\n}\n\nlet y = 0;\nlet mut x = Foo { x: None };\nx.x = Some(&y);\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":1665,"byte_end":1674,"line_start":42,"line_end":42,"column_start":17,"column_end":26,"is_primary":false,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":17,"highlight_end":26}],"label":"capture occurs here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":1682,"byte_end":1683,"line_start":42,"line_end":42,"column_start":34,"column_end":35,"is_primary":true,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":34,"highlight_end":35}],"label":"does not live long enough","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":2184,"byte_end":2185,"line_start":52,"line_end":52,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    };","highlight_start":5,"highlight_end":6}],"label":"borrowed value dropped before borrower","suggested_replacement":null,"expansion":null}],"children":[{"message":"values in a scope are dropped in the opposite order they are created","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":null}
{"message":"`y` does not live long enough (Ast)","code":{"code":"E0597","explanation":"\nThis error occurs because a borrow was made inside a variable which has a\ngreater lifetime than the borrowed one.\n\nExample of erroneous code:\n\n```compile_fail,E0597\nstruct Foo<'a> {\n    x: Option<&'a u32>,\n}\n\nlet mut x = Foo { x: None };\nlet y = 0;\nx.x = Some(&y); // error: `y` does not live long enough\n```\n\nIn here, `x` is created before `y` and therefore has a greater lifetime. Always\nkeep in mind that values in a scope are dropped in the opposite order they are\ncreated. So to fix the previous example, just make the `y` lifetime greater than\nthe `x`'s one:\n\n```\nstruct Foo<'a> {\n    x: Option<&'a u32>,\n}\n\nlet y = 0;\nlet mut x = Foo { x: None };\nx.x = Some(&y);\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":1665,"byte_end":1674,"line_start":42,"line_end":42,"column_start":17,"column_end":26,"is_primary":false,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":17,"highlight_end":26}],"label":"capture occurs here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":1693,"byte_end":1694,"line_start":42,"line_end":42,"column_start":45,"column_end":46,"is_primary":true,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":45,"highlight_end":46}],"label":"does not live long enough","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":2184,"byte_end":2185,"line_start":52,"line_end":52,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    };","highlight_start":5,"highlight_end":6}],"label":"borrowed value dropped before borrower","suggested_replacement":null,"expansion":null}],"children":[{"message":"values in a scope are dropped in the opposite order they are created","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":null}
{"message":"closure may outlive the current function, but it borrows `x`, which is owned by the current function (Ast)","code":{"code":"E0373","explanation":"\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behaviour is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":2985,"byte_end":2986,"line_start":81,"line_end":81,"column_start":34,"column_end":35,"is_primary":false,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":34,"highlight_end":35}],"label":"`x` is borrowed here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":2968,"byte_end":2977,"line_start":81,"line_end":81,"column_start":17,"column_end":26,"is_primary":true,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":17,"highlight_end":26}],"label":"may outlive borrowed value `x`","suggested_replacement":null,"expansion":null}],"children":[{"message":"to force the closure to take ownership of `x` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":2968,"byte_end":2977,"line_start":81,"line_end":81,"column_start":17,"column_end":26,"is_primary":true,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":17,"highlight_end":26}],"label":null,"suggested_replacement":"move |t: bool|","expansion":null}],"children":[],"rendered":null}],"rendered":null}
{"message":"closure may outlive the current function, but it borrows `y`, which is owned by the current function (Ast)","code":{"code":"E0373","explanation":"\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behaviour is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":2996,"byte_end":2997,"line_start":81,"line_end":81,"column_start":45,"column_end":46,"is_primary":false,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":45,"highlight_end":46}],"label":"`y` is borrowed here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":2968,"byte_end":2977,"line_start":81,"line_end":81,"column_start":17,"column_end":26,"is_primary":true,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":17,"highlight_end":26}],"label":"may outlive borrowed value `y`","suggested_replacement":null,"expansion":null}],"children":[{"message":"to force the closure to take ownership of `y` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":2968,"byte_end":2977,"line_start":81,"line_end":81,"column_start":17,"column_end":26,"is_primary":true,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":17,"highlight_end":26}],"label":null,"suggested_replacement":"move |t: bool|","expansion":null}],"children":[],"rendered":null}],"rendered":null}
{"message":"closure may outlive the current function, but it borrows `x`, which is owned by the current function (Ast)","code":{"code":"E0373","explanation":"\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behaviour is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":3476,"byte_end":3477,"line_start":96,"line_end":96,"column_start":34,"column_end":35,"is_primary":false,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":34,"highlight_end":35}],"label":"`x` is borrowed here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":3459,"byte_end":3468,"line_start":96,"line_end":96,"column_start":17,"column_end":26,"is_primary":true,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":17,"highlight_end":26}],"label":"may outlive borrowed value `x`","suggested_replacement":null,"expansion":null}],"children":[{"message":"to force the closure to take ownership of `x` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":3459,"byte_end":3468,"line_start":96,"line_end":96,"column_start":17,"column_end":26,"is_primary":true,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":17,"highlight_end":26}],"label":null,"suggested_replacement":"move |t: bool|","expansion":null}],"children":[],"rendered":null}],"rendered":null}
{"message":"closure may outlive the current function, but it borrows `y`, which is owned by the current function (Ast)","code":{"code":"E0373","explanation":"\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behaviour is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":3487,"byte_end":3488,"line_start":96,"line_end":96,"column_start":45,"column_end":46,"is_primary":false,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":45,"highlight_end":46}],"label":"`y` is borrowed here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":3459,"byte_end":3468,"line_start":96,"line_end":96,"column_start":17,"column_end":26,"is_primary":true,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":17,"highlight_end":26}],"label":"may outlive borrowed value `y`","suggested_replacement":null,"expansion":null}],"children":[{"message":"to force the closure to take ownership of `y` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":3459,"byte_end":3468,"line_start":96,"line_end":96,"column_start":17,"column_end":26,"is_primary":true,"text":[{"text":"        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":17,"highlight_end":26}],"label":null,"suggested_replacement":"move |t: bool|","expansion":null}],"children":[],"rendered":null}],"rendered":null}
{"message":"closure may outlive the current function, but it borrows `x`, which is owned by the current function (Ast)","code":{"code":"E0373","explanation":"\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behaviour is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":4310,"byte_end":4311,"line_start":124,"line_end":124,"column_start":38,"column_end":39,"is_primary":false,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":38,"highlight_end":39}],"label":"`x` is borrowed here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":4293,"byte_end":4302,"line_start":124,"line_end":124,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":"may outlive borrowed value `x`","suggested_replacement":null,"expansion":null}],"children":[{"message":"to force the closure to take ownership of `x` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":4293,"byte_end":4302,"line_start":124,"line_end":124,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":null,"suggested_replacement":"move |t: bool|","expansion":null}],"children":[],"rendered":null}],"rendered":null}
{"message":"closure may outlive the current function, but it borrows `y`, which is owned by the current function (Ast)","code":{"code":"E0373","explanation":"\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behaviour is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":4321,"byte_end":4322,"line_start":124,"line_end":124,"column_start":49,"column_end":50,"is_primary":false,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":49,"highlight_end":50}],"label":"`y` is borrowed here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":4293,"byte_end":4302,"line_start":124,"line_end":124,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":"may outlive borrowed value `y`","suggested_replacement":null,"expansion":null}],"children":[{"message":"to force the closure to take ownership of `y` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":4293,"byte_end":4302,"line_start":124,"line_end":124,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":null,"suggested_replacement":"move |t: bool|","expansion":null}],"children":[],"rendered":null}],"rendered":null}
{"message":"closure may outlive the current function, but it borrows `x`, which is owned by the current function (Ast)","code":{"code":"E0373","explanation":"\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behaviour is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":4884,"byte_end":4885,"line_start":142,"line_end":142,"column_start":38,"column_end":39,"is_primary":false,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":38,"highlight_end":39}],"label":"`x` is borrowed here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":4867,"byte_end":4876,"line_start":142,"line_end":142,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":"may outlive borrowed value `x`","suggested_replacement":null,"expansion":null}],"children":[{"message":"to force the closure to take ownership of `x` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":4867,"byte_end":4876,"line_start":142,"line_end":142,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":null,"suggested_replacement":"move |t: bool|","expansion":null}],"children":[],"rendered":null}],"rendered":null}
{"message":"closure may outlive the current function, but it borrows `y`, which is owned by the current function (Ast)","code":{"code":"E0373","explanation":"\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behaviour is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":4895,"byte_end":4896,"line_start":142,"line_end":142,"column_start":49,"column_end":50,"is_primary":false,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":49,"highlight_end":50}],"label":"`y` is borrowed here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":4867,"byte_end":4876,"line_start":142,"line_end":142,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":"may outlive borrowed value `y`","suggested_replacement":null,"expansion":null}],"children":[{"message":"to force the closure to take ownership of `y` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":4867,"byte_end":4876,"line_start":142,"line_end":142,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":null,"suggested_replacement":"move |t: bool|","expansion":null}],"children":[],"rendered":null}],"rendered":null}
{"message":"closure may outlive the current function, but it borrows `x`, which is owned by the current function (Ast)","code":{"code":"E0373","explanation":"\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behaviour is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":5910,"byte_end":5911,"line_start":174,"line_end":174,"column_start":38,"column_end":39,"is_primary":false,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":38,"highlight_end":39}],"label":"`x` is borrowed here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":5893,"byte_end":5902,"line_start":174,"line_end":174,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":"may outlive borrowed value `x`","suggested_replacement":null,"expansion":null}],"children":[{"message":"to force the closure to take ownership of `x` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":5893,"byte_end":5902,"line_start":174,"line_end":174,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":null,"suggested_replacement":"move |t: bool|","expansion":null}],"children":[],"rendered":null}],"rendered":null}
{"message":"closure may outlive the current function, but it borrows `y`, which is owned by the current function (Ast)","code":{"code":"E0373","explanation":"\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behaviour is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":5921,"byte_end":5922,"line_start":174,"line_end":174,"column_start":49,"column_end":50,"is_primary":false,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":49,"highlight_end":50}],"label":"`y` is borrowed here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":5893,"byte_end":5902,"line_start":174,"line_end":174,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":"may outlive borrowed value `y`","suggested_replacement":null,"expansion":null}],"children":[{"message":"to force the closure to take ownership of `y` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":5893,"byte_end":5902,"line_start":174,"line_end":174,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":null,"suggested_replacement":"move |t: bool|","expansion":null}],"children":[],"rendered":null}],"rendered":null}
{"message":"closure may outlive the current function, but it borrows `x`, which is owned by the current function (Ast)","code":{"code":"E0373","explanation":"\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behaviour is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":6577,"byte_end":6578,"line_start":193,"line_end":193,"column_start":38,"column_end":39,"is_primary":false,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":38,"highlight_end":39}],"label":"`x` is borrowed here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":6560,"byte_end":6569,"line_start":193,"line_end":193,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":"may outlive borrowed value `x`","suggested_replacement":null,"expansion":null}],"children":[{"message":"to force the closure to take ownership of `x` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":6560,"byte_end":6569,"line_start":193,"line_end":193,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":null,"suggested_replacement":"move |t: bool|","expansion":null}],"children":[],"rendered":null}],"rendered":null}
{"message":"closure may outlive the current function, but it borrows `y`, which is owned by the current function (Ast)","code":{"code":"E0373","explanation":"\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behaviour is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":6588,"byte_end":6589,"line_start":193,"line_end":193,"column_start":49,"column_end":50,"is_primary":false,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":49,"highlight_end":50}],"label":"`y` is borrowed here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":6560,"byte_end":6569,"line_start":193,"line_end":193,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":"may outlive borrowed value `y`","suggested_replacement":null,"expansion":null}],"children":[{"message":"to force the closure to take ownership of `y` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":6560,"byte_end":6569,"line_start":193,"line_end":193,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":null,"suggested_replacement":"move |t: bool|","expansion":null}],"children":[],"rendered":null}],"rendered":null}
{"message":"closure may outlive the current function, but it borrows `x`, which is owned by the current function (Ast)","code":{"code":"E0373","explanation":"\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behaviour is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":7614,"byte_end":7615,"line_start":225,"line_end":225,"column_start":38,"column_end":39,"is_primary":false,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":38,"highlight_end":39}],"label":"`x` is borrowed here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":7597,"byte_end":7606,"line_start":225,"line_end":225,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":"may outlive borrowed value `x`","suggested_replacement":null,"expansion":null}],"children":[{"message":"to force the closure to take ownership of `x` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":7597,"byte_end":7606,"line_start":225,"line_end":225,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":null,"suggested_replacement":"move |t: bool|","expansion":null}],"children":[],"rendered":null}],"rendered":null}
{"message":"closure may outlive the current function, but it borrows `y`, which is owned by the current function (Ast)","code":{"code":"E0373","explanation":"\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behaviour is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":7625,"byte_end":7626,"line_start":225,"line_end":225,"column_start":49,"column_end":50,"is_primary":false,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":49,"highlight_end":50}],"label":"`y` is borrowed here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":7597,"byte_end":7606,"line_start":225,"line_end":225,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":"may outlive borrowed value `y`","suggested_replacement":null,"expansion":null}],"children":[{"message":"to force the closure to take ownership of `y` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":7597,"byte_end":7606,"line_start":225,"line_end":225,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":null,"suggested_replacement":"move |t: bool|","expansion":null}],"children":[],"rendered":null}],"rendered":null}
{"message":"closure may outlive the current function, but it borrows `x`, which is owned by the current function (Ast)","code":{"code":"E0373","explanation":"\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behaviour is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":8215,"byte_end":8216,"line_start":243,"line_end":243,"column_start":38,"column_end":39,"is_primary":false,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":38,"highlight_end":39}],"label":"`x` is borrowed here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":8198,"byte_end":8207,"line_start":243,"line_end":243,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":"may outlive borrowed value `x`","suggested_replacement":null,"expansion":null}],"children":[{"message":"to force the closure to take ownership of `x` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":8198,"byte_end":8207,"line_start":243,"line_end":243,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":null,"suggested_replacement":"move |t: bool|","expansion":null}],"children":[],"rendered":null}],"rendered":null}
{"message":"closure may outlive the current function, but it borrows `y`, which is owned by the current function (Ast)","code":{"code":"E0373","explanation":"\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behaviour is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":8226,"byte_end":8227,"line_start":243,"line_end":243,"column_start":49,"column_end":50,"is_primary":false,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":49,"highlight_end":50}],"label":"`y` is borrowed here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":8198,"byte_end":8207,"line_start":243,"line_end":243,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":"may outlive borrowed value `y`","suggested_replacement":null,"expansion":null}],"children":[{"message":"to force the closure to take ownership of `y` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/region-borrow-params-issue-29793-small.rs","byte_start":8198,"byte_end":8207,"line_start":243,"line_end":243,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)","highlight_start":21,"highlight_end":30}],"label":null,"suggested_replacement":"move |t: bool|","expansion":null}],"children":[],"rendered":null}],"rendered":null}
{"message":"aborting due to 20 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":null}
