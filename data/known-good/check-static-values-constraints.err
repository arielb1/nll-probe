{"message":"destructors cannot be evaluated at compile-time","code":{"code":"E0493","explanation":null},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-emergency/src/test/compile-fail/check-static-values-constraints.rs","byte_start":2363,"byte_end":2551,"line_start":75,"line_end":77,"column_start":43,"column_end":81,"is_primary":true,"text":[{"text":"                                        ..SafeStruct{field1: SafeEnum::Variant3(WithDtor),","highlight_start":43,"highlight_end":91},{"text":"//~^ ERROR destructors cannot be evaluated at compile-time","highlight_start":1,"highlight_end":59},{"text":"                                                     field2: SafeEnum::Variant1}};","highlight_start":1,"highlight_end":81}],"label":"statics cannot evaluate destructors","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"allocations are not allowed in statics","code":{"code":"E0010","explanation":"\nThe value of statics and constants must be known at compile time, and they live\nfor the entire lifetime of a program. Creating a boxed value allocates memory on\nthe heap at runtime, and therefore cannot be done at compile time. Erroneous\ncode example:\n\n```compile_fail,E0010\n#![feature(box_syntax)]\n\nconst CON : Box<i32> = box 0;\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-emergency/src/test/compile-fail/check-static-values-constraints.rs","byte_start":2731,"byte_end":2742,"line_start":89,"line_end":89,"column_start":33,"column_end":44,"is_primary":true,"text":[{"text":"static STATIC11: Box<MyOwned> = box MyOwned;","highlight_start":33,"highlight_end":44}],"label":"allocation not allowed in statics","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"calls in statics are limited to constant functions, struct and enum constructors","code":{"code":"E0015","explanation":"\nThe only functions that can be called in static or constant expressions are\n`const` functions, and struct/enum constructors. `const` functions are only\navailable on a nightly compiler. Rust currently does not support more general\ncompile-time function execution.\n\n```\nconst FOO: Option<u8> = Some(1); // enum constructor\nstruct Bar {x: u8}\nconst BAR: Bar = Bar {x: 1}; // struct constructor\n```\n\nSee [RFC 911] for more details on the design of `const fn`s.\n\n[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-emergency/src/test/compile-fail/check-static-values-constraints.rs","byte_start":3114,"byte_end":3131,"line_start":99,"line_end":99,"column_start":32,"column_end":49,"is_primary":true,"text":[{"text":"    field2: SafeEnum::Variant4(\"str\".to_string())","highlight_start":32,"highlight_end":49}],"label":null,"suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"allocations are not allowed in statics","code":{"code":"E0010","explanation":"\nThe value of statics and constants must be known at compile time, and they live\nfor the entire lifetime of a program. Creating a boxed value allocates memory on\nthe heap at runtime, and therefore cannot be done at compile time. Erroneous\ncode example:\n\n```compile_fail,E0010\n#![feature(box_syntax)]\n\nconst CON : Box<i32> = box 0;\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-emergency/src/test/compile-fail/check-static-values-constraints.rs","byte_start":3249,"byte_end":3260,"line_start":104,"line_end":104,"column_start":5,"column_end":16,"is_primary":true,"text":[{"text":"    box MyOwned, //~ ERROR allocations are not allowed in statics","highlight_start":5,"highlight_end":16}],"label":"allocation not allowed in statics","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"allocations are not allowed in statics","code":{"code":"E0010","explanation":"\nThe value of statics and constants must be known at compile time, and they live\nfor the entire lifetime of a program. Creating a boxed value allocates memory on\nthe heap at runtime, and therefore cannot be done at compile time. Erroneous\ncode example:\n\n```compile_fail,E0010\n#![feature(box_syntax)]\n\nconst CON : Box<i32> = box 0;\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-emergency/src/test/compile-fail/check-static-values-constraints.rs","byte_start":3315,"byte_end":3326,"line_start":105,"line_end":105,"column_start":5,"column_end":16,"is_primary":true,"text":[{"text":"    box MyOwned, //~ ERROR allocations are not allowed in statics","highlight_start":5,"highlight_end":16}],"label":"allocation not allowed in statics","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"allocations are not allowed in statics","code":{"code":"E0010","explanation":"\nThe value of statics and constants must be known at compile time, and they live\nfor the entire lifetime of a program. Creating a boxed value allocates memory on\nthe heap at runtime, and therefore cannot be done at compile time. Erroneous\ncode example:\n\n```compile_fail,E0010\n#![feature(box_syntax)]\n\nconst CON : Box<i32> = box 0;\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-emergency/src/test/compile-fail/check-static-values-constraints.rs","byte_start":3454,"byte_end":3465,"line_start":109,"line_end":109,"column_start":6,"column_end":17,"is_primary":true,"text":[{"text":"    &box MyOwned, //~ ERROR allocations are not allowed in statics","highlight_start":6,"highlight_end":17}],"label":"allocation not allowed in statics","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"allocations are not allowed in statics","code":{"code":"E0010","explanation":"\nThe value of statics and constants must be known at compile time, and they live\nfor the entire lifetime of a program. Creating a boxed value allocates memory on\nthe heap at runtime, and therefore cannot be done at compile time. Erroneous\ncode example:\n\n```compile_fail,E0010\n#![feature(box_syntax)]\n\nconst CON : Box<i32> = box 0;\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-emergency/src/test/compile-fail/check-static-values-constraints.rs","byte_start":3521,"byte_end":3532,"line_start":110,"line_end":110,"column_start":6,"column_end":17,"is_primary":true,"text":[{"text":"    &box MyOwned, //~ ERROR allocations are not allowed in statics","highlight_start":6,"highlight_end":17}],"label":"allocation not allowed in statics","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"allocations are not allowed in statics","code":{"code":"E0010","explanation":"\nThe value of statics and constants must be known at compile time, and they live\nfor the entire lifetime of a program. Creating a boxed value allocates memory on\nthe heap at runtime, and therefore cannot be done at compile time. Erroneous\ncode example:\n\n```compile_fail,E0010\n#![feature(box_syntax)]\n\nconst CON : Box<i32> = box 0;\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-emergency/src/test/compile-fail/check-static-values-constraints.rs","byte_start":3674,"byte_end":3679,"line_start":116,"line_end":116,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    box 3;","highlight_start":5,"highlight_end":10}],"label":"allocation not allowed in statics","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"cannot move out of static item (Ast)","code":{"code":"E0507","explanation":"\nYou tried to move out of a value which was borrowed. Erroneous code example:\n\n```compile_fail,E0507\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n}\n```\n\nHere, the `nothing_is_true` method takes the ownership of `self`. However,\n`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\nwhich is a borrow of the content owned by the `RefCell`. To fix this error,\nyou have three choices:\n\n* Try to avoid moving the variable.\n* Somehow reclaim the ownership.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(&self) {} // First case, we don't take ownership\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n    let x = x.into_inner(); // we get back ownership\n\n    x.nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\n#[derive(Clone, Copy)] // we implement the Copy trait\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nMoving a member out of a mutably borrowed struct will also cause E0507 error:\n\n```compile_fail,E0507\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nstruct Batcave {\n    knight: TheDarkKnight\n}\n\nfn main() {\n    let mut cave = Batcave {\n        knight: TheDarkKnight\n    };\n    let borrowed = &mut cave;\n\n    borrowed.knight.nothing_is_true(); // E0507\n}\n```\n\nIt is fine only if you put something back. `mem::replace` can be used for that:\n\n```\n# struct TheDarkKnight;\n# impl TheDarkKnight { fn nothing_is_true(self) {} }\n# struct Batcave { knight: TheDarkKnight }\nuse std::mem;\n\nlet mut cave = Batcave {\n    knight: TheDarkKnight\n};\nlet borrowed = &mut cave;\n\nmem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n```\n\nYou can find more information about borrowing in the rust-book:\nhttp://doc.rust-lang.org/book/first-edition/references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-emergency/src/test/compile-fail/check-static-values-constraints.rs","byte_start":3792,"byte_end":3793,"line_start":120,"line_end":120,"column_start":45,"column_end":46,"is_primary":true,"text":[{"text":"    let y = { static x: Box<isize> = box 3; x };","highlight_start":45,"highlight_end":46}],"label":"cannot move out of static item","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"allocations are not allowed in statics","code":{"code":"E0010","explanation":"\nThe value of statics and constants must be known at compile time, and they live\nfor the entire lifetime of a program. Creating a boxed value allocates memory on\nthe heap at runtime, and therefore cannot be done at compile time. Erroneous\ncode example:\n\n```compile_fail,E0010\n#![feature(box_syntax)]\n\nconst CON : Box<i32> = box 0;\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-emergency/src/test/compile-fail/check-static-values-constraints.rs","byte_start":3785,"byte_end":3790,"line_start":120,"line_end":120,"column_start":38,"column_end":43,"is_primary":true,"text":[{"text":"    let y = { static x: Box<isize> = box 3; x };","highlight_start":38,"highlight_end":43}],"label":"allocation not allowed in statics","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"cannot move out of static item (Mir)","code":{"code":"E0507","explanation":"\nYou tried to move out of a value which was borrowed. Erroneous code example:\n\n```compile_fail,E0507\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n}\n```\n\nHere, the `nothing_is_true` method takes the ownership of `self`. However,\n`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\nwhich is a borrow of the content owned by the `RefCell`. To fix this error,\nyou have three choices:\n\n* Try to avoid moving the variable.\n* Somehow reclaim the ownership.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(&self) {} // First case, we don't take ownership\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n    let x = x.into_inner(); // we get back ownership\n\n    x.nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\n#[derive(Clone, Copy)] // we implement the Copy trait\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nMoving a member out of a mutably borrowed struct will also cause E0507 error:\n\n```compile_fail,E0507\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nstruct Batcave {\n    knight: TheDarkKnight\n}\n\nfn main() {\n    let mut cave = Batcave {\n        knight: TheDarkKnight\n    };\n    let borrowed = &mut cave;\n\n    borrowed.knight.nothing_is_true(); // E0507\n}\n```\n\nIt is fine only if you put something back. `mem::replace` can be used for that:\n\n```\n# struct TheDarkKnight;\n# impl TheDarkKnight { fn nothing_is_true(self) {} }\n# struct Batcave { knight: TheDarkKnight }\nuse std::mem;\n\nlet mut cave = Batcave {\n    knight: TheDarkKnight\n};\nlet borrowed = &mut cave;\n\nmem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n```\n\nYou can find more information about borrowing in the rust-book:\nhttp://doc.rust-lang.org/book/first-edition/references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-emergency/src/test/compile-fail/check-static-values-constraints.rs","byte_start":3792,"byte_end":3793,"line_start":120,"line_end":120,"column_start":45,"column_end":46,"is_primary":true,"text":[{"text":"    let y = { static x: Box<isize> = box 3; x };","highlight_start":45,"highlight_end":46}],"label":"cannot move out of static item","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"aborting due to 11 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":null}
