{"message":"cannot move `x1` into closure because it is borrowed (Ast)","code":{"code":"E0504","explanation":"\nThis error occurs when an attempt is made to move a borrowed variable into a\nclosure.\n\nExample of erroneous code:\n\n```compile_fail,E0504\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_num = FancyNum { num: 5 };\n    let fancy_ref = &fancy_num;\n\n    let x = move || {\n        println!(\"child function: {}\", fancy_num.num);\n        // error: cannot move `fancy_num` into closure because it is borrowed\n    };\n\n    x();\n    println!(\"main function: {}\", fancy_ref.num);\n}\n```\n\nHere, `fancy_num` is borrowed by `fancy_ref` and so cannot be moved into\nthe closure `x`. There is no way to move a value into a closure while it is\nborrowed, as that would invalidate the borrow.\n\nIf the closure can't outlive the value being moved, try using a reference\nrather than moving:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_num = FancyNum { num: 5 };\n    let fancy_ref = &fancy_num;\n\n    let x = move || {\n        // fancy_ref is usable here because it doesn't move `fancy_num`\n        println!(\"child function: {}\", fancy_ref.num);\n    };\n\n    x();\n\n    println!(\"main function: {}\", fancy_num.num);\n}\n```\n\nIf the value has to be borrowed and then moved, try limiting the lifetime of\nthe borrow using a scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_num = FancyNum { num: 5 };\n\n    {\n        let fancy_ref = &fancy_num;\n        println!(\"main function: {}\", fancy_ref.num);\n        // `fancy_ref` goes out of scope here\n    }\n\n    let x = move || {\n        // `fancy_num` can be moved now (no more references exist)\n        println!(\"child function: {}\", fancy_num.num);\n    };\n\n    x();\n}\n```\n\nIf the lifetime of a reference isn't enough, such as in the case of threading,\nconsider using an `Arc` to create a reference-counted value:\n\n```\nuse std::sync::Arc;\nuse std::thread;\n\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_ref1 = Arc::new(FancyNum { num: 5 });\n    let fancy_ref2 = fancy_ref1.clone();\n\n    let x = thread::spawn(move || {\n        // `fancy_ref1` can be moved and has a `'static` lifetime\n        println!(\"child thread: {}\", fancy_ref1.num);\n    });\n\n    x.join().expect(\"child thread should finish\");\n    println!(\"main thread: {}\", fancy_ref2.num);\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":613,"byte_end":615,"line_start":19,"line_end":19,"column_start":15,"column_end":17,"is_primary":false,"text":[{"text":"    let p1 = &x1;","highlight_start":15,"highlight_end":17}],"label":"borrow of `x1` occurs here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":703,"byte_end":705,"line_start":23,"line_end":23,"column_start":14,"column_end":16,"is_primary":true,"text":[{"text":"        drop(x1); //~ ERROR cannot move `x1` into closure because it is borrowed","highlight_start":14,"highlight_end":16}],"label":"move into closure occurs here","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"cannot move `x2` into closure because it is borrowed (Ast)","code":{"code":"E0504","explanation":"\nThis error occurs when an attempt is made to move a borrowed variable into a\nclosure.\n\nExample of erroneous code:\n\n```compile_fail,E0504\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_num = FancyNum { num: 5 };\n    let fancy_ref = &fancy_num;\n\n    let x = move || {\n        println!(\"child function: {}\", fancy_num.num);\n        // error: cannot move `fancy_num` into closure because it is borrowed\n    };\n\n    x();\n    println!(\"main function: {}\", fancy_ref.num);\n}\n```\n\nHere, `fancy_num` is borrowed by `fancy_ref` and so cannot be moved into\nthe closure `x`. There is no way to move a value into a closure while it is\nborrowed, as that would invalidate the borrow.\n\nIf the closure can't outlive the value being moved, try using a reference\nrather than moving:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_num = FancyNum { num: 5 };\n    let fancy_ref = &fancy_num;\n\n    let x = move || {\n        // fancy_ref is usable here because it doesn't move `fancy_num`\n        println!(\"child function: {}\", fancy_ref.num);\n    };\n\n    x();\n\n    println!(\"main function: {}\", fancy_num.num);\n}\n```\n\nIf the value has to be borrowed and then moved, try limiting the lifetime of\nthe borrow using a scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_num = FancyNum { num: 5 };\n\n    {\n        let fancy_ref = &fancy_num;\n        println!(\"main function: {}\", fancy_ref.num);\n        // `fancy_ref` goes out of scope here\n    }\n\n    let x = move || {\n        // `fancy_num` can be moved now (no more references exist)\n        println!(\"child function: {}\", fancy_num.num);\n    };\n\n    x();\n}\n```\n\nIf the lifetime of a reference isn't enough, such as in the case of threading,\nconsider using an `Arc` to create a reference-counted value:\n\n```\nuse std::sync::Arc;\nuse std::thread;\n\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_ref1 = Arc::new(FancyNum { num: 5 });\n    let fancy_ref2 = fancy_ref1.clone();\n\n    let x = thread::spawn(move || {\n        // `fancy_ref1` can be moved and has a `'static` lifetime\n        println!(\"child thread: {}\", fancy_ref1.num);\n    });\n\n    x.join().expect(\"child thread should finish\");\n    println!(\"main thread: {}\", fancy_ref2.num);\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":659,"byte_end":661,"line_start":21,"line_end":21,"column_start":15,"column_end":17,"is_primary":false,"text":[{"text":"    let p2 = &x2;","highlight_start":15,"highlight_end":17}],"label":"borrow of `x2` occurs here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":784,"byte_end":786,"line_start":24,"line_end":24,"column_start":14,"column_end":16,"is_primary":true,"text":[{"text":"        drop(x2); //~ ERROR cannot move `x2` into closure because it is borrowed","highlight_start":14,"highlight_end":16}],"label":"move into closure occurs here","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"capture of moved value: `x1` (Ast)","code":{"code":"E0382","explanation":"\nThis error occurs when an attempt is made to use a variable after its contents\nhave been moved elsewhere. For example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`.  Implicit\ncloning is more convienient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the chapter in the\nBook:\n\nhttps://doc.rust-lang.org/book/first-edition/ownership.html\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1057,"byte_end":1059,"line_start":36,"line_end":36,"column_start":14,"column_end":16,"is_primary":true,"text":[{"text":"        drop(x1); //~ ERROR capture of moved value: `x1`","highlight_start":14,"highlight_end":16}],"label":"value captured here after move","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":970,"byte_end":972,"line_start":32,"line_end":32,"column_start":10,"column_end":12,"is_primary":false,"text":[{"text":"    drop(x1);","highlight_start":10,"highlight_end":12}],"label":"value moved here","suggested_replacement":null,"expansion":null}],"children":[{"message":"move occurs because `x1` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":null}
{"message":"capture of moved value: `x2` (Ast)","code":{"code":"E0382","explanation":"\nThis error occurs when an attempt is made to use a variable after its contents\nhave been moved elsewhere. For example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`.  Implicit\ncloning is more convienient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the chapter in the\nBook:\n\nhttps://doc.rust-lang.org/book/first-edition/ownership.html\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1114,"byte_end":1116,"line_start":37,"line_end":37,"column_start":14,"column_end":16,"is_primary":true,"text":[{"text":"        drop(x2); //~ ERROR capture of moved value: `x2`","highlight_start":14,"highlight_end":16}],"label":"value captured here after move","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1012,"byte_end":1014,"line_start":34,"line_end":34,"column_start":10,"column_end":12,"is_primary":false,"text":[{"text":"    drop(x2);","highlight_start":10,"highlight_end":12}],"label":"value moved here","suggested_replacement":null,"expansion":null}],"children":[{"message":"move occurs because `x2` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":null}
{"message":"cannot move `x` into closure because it is borrowed (Ast)","code":{"code":"E0504","explanation":"\nThis error occurs when an attempt is made to move a borrowed variable into a\nclosure.\n\nExample of erroneous code:\n\n```compile_fail,E0504\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_num = FancyNum { num: 5 };\n    let fancy_ref = &fancy_num;\n\n    let x = move || {\n        println!(\"child function: {}\", fancy_num.num);\n        // error: cannot move `fancy_num` into closure because it is borrowed\n    };\n\n    x();\n    println!(\"main function: {}\", fancy_ref.num);\n}\n```\n\nHere, `fancy_num` is borrowed by `fancy_ref` and so cannot be moved into\nthe closure `x`. There is no way to move a value into a closure while it is\nborrowed, as that would invalidate the borrow.\n\nIf the closure can't outlive the value being moved, try using a reference\nrather than moving:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_num = FancyNum { num: 5 };\n    let fancy_ref = &fancy_num;\n\n    let x = move || {\n        // fancy_ref is usable here because it doesn't move `fancy_num`\n        println!(\"child function: {}\", fancy_ref.num);\n    };\n\n    x();\n\n    println!(\"main function: {}\", fancy_num.num);\n}\n```\n\nIf the value has to be borrowed and then moved, try limiting the lifetime of\nthe borrow using a scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_num = FancyNum { num: 5 };\n\n    {\n        let fancy_ref = &fancy_num;\n        println!(\"main function: {}\", fancy_ref.num);\n        // `fancy_ref` goes out of scope here\n    }\n\n    let x = move || {\n        // `fancy_num` can be moved now (no more references exist)\n        println!(\"child function: {}\", fancy_num.num);\n    };\n\n    x();\n}\n```\n\nIf the lifetime of a reference isn't enough, such as in the case of threading,\nconsider using an `Arc` to create a reference-counted value:\n\n```\nuse std::sync::Arc;\nuse std::thread;\n\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_ref1 = Arc::new(FancyNum { num: 5 });\n    let fancy_ref2 = fancy_ref1.clone();\n\n    let x = thread::spawn(move || {\n        // `fancy_ref1` can be moved and has a `'static` lifetime\n        println!(\"child thread: {}\", fancy_ref1.num);\n    });\n\n    x.join().expect(\"child thread should finish\");\n    println!(\"main thread: {}\", fancy_ref2.num);\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1238,"byte_end":1239,"line_start":43,"line_end":43,"column_start":14,"column_end":15,"is_primary":false,"text":[{"text":"    let p = &x;","highlight_start":14,"highlight_end":15}],"label":"borrow of `x` occurs here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1281,"byte_end":1282,"line_start":45,"line_end":45,"column_start":14,"column_end":15,"is_primary":true,"text":[{"text":"        drop(x); //~ ERROR cannot move `x` into closure because it is borrowed","highlight_start":14,"highlight_end":15}],"label":"move into closure occurs here","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"use of moved value: `x` (Ast)","code":{"code":"E0382","explanation":"\nThis error occurs when an attempt is made to use a variable after its contents\nhave been moved elsewhere. For example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`.  Implicit\ncloning is more convienient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the chapter in the\nBook:\n\nhttps://doc.rust-lang.org/book/first-edition/ownership.html\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1360,"byte_end":1361,"line_start":46,"line_end":46,"column_start":14,"column_end":15,"is_primary":true,"text":[{"text":"        drop(x); //~ ERROR use of moved value: `x`","highlight_start":14,"highlight_end":15}],"label":"value used here after move","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1281,"byte_end":1282,"line_start":45,"line_end":45,"column_start":14,"column_end":15,"is_primary":false,"text":[{"text":"        drop(x); //~ ERROR cannot move `x` into closure because it is borrowed","highlight_start":14,"highlight_end":15}],"label":"value moved here","suggested_replacement":null,"expansion":null}],"children":[{"message":"move occurs because `x` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":null}
{"message":"capture of moved value: `x` (Ast)","code":{"code":"E0382","explanation":"\nThis error occurs when an attempt is made to use a variable after its contents\nhave been moved elsewhere. For example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`.  Implicit\ncloning is more convienient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the chapter in the\nBook:\n\nhttps://doc.rust-lang.org/book/first-edition/ownership.html\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1533,"byte_end":1534,"line_start":55,"line_end":55,"column_start":14,"column_end":15,"is_primary":true,"text":[{"text":"        drop(x); //~ ERROR capture of moved value: `x`","highlight_start":14,"highlight_end":15}],"label":"value captured here after move","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1489,"byte_end":1490,"line_start":53,"line_end":53,"column_start":10,"column_end":11,"is_primary":false,"text":[{"text":"    drop(x);","highlight_start":10,"highlight_end":11}],"label":"value moved here","suggested_replacement":null,"expansion":null}],"children":[{"message":"move occurs because `x` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":null}
{"message":"use of moved value: `x` (Ast)","code":{"code":"E0382","explanation":"\nThis error occurs when an attempt is made to use a variable after its contents\nhave been moved elsewhere. For example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`.  Implicit\ncloning is more convienient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the chapter in the\nBook:\n\nhttps://doc.rust-lang.org/book/first-edition/ownership.html\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1588,"byte_end":1589,"line_start":56,"line_end":56,"column_start":14,"column_end":15,"is_primary":true,"text":[{"text":"        drop(x); //~ ERROR use of moved value: `x`","highlight_start":14,"highlight_end":15}],"label":"value used here after move","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1533,"byte_end":1534,"line_start":55,"line_end":55,"column_start":14,"column_end":15,"is_primary":false,"text":[{"text":"        drop(x); //~ ERROR capture of moved value: `x`","highlight_start":14,"highlight_end":15}],"label":"value moved here","suggested_replacement":null,"expansion":null}],"children":[{"message":"move occurs because `x` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":null}
{"message":"cannot move out of `x1` because it is borrowed (Mir)","code":{"code":"E0505","explanation":"\nA value was moved out while it was still borrowed.\n\nErroneous code example:\n\n```compile_fail,E0505\nstruct Value {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    {\n        let _ref_to_val: &Value = &x;\n        eat(x);\n    }\n}\n```\n\nHere, the function `eat` takes the ownership of `x`. However,\n`x` cannot be moved because it was borrowed to `_ref_to_val`.\nTo fix that you can do few different things:\n\n* Try to avoid moving the variable.\n* Release borrow before move.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nstruct Value {}\n\nfn eat(val: &Value) {}\n\nfn main() {\n    let x = Value{};\n    {\n        let _ref_to_val: &Value = &x;\n        eat(&x); // pass by reference, if it's possible\n    }\n}\n```\n\nOr:\n\n```\nstruct Value {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    {\n        let _ref_to_val: &Value = &x;\n    }\n    eat(x); // release borrow and then move it.\n}\n```\n\nOr:\n\n```\n#[derive(Clone, Copy)] // implement Copy trait\nstruct Value {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    {\n        let _ref_to_val: &Value = &x;\n        eat(x); // it will be copied here.\n    }\n}\n```\n\nYou can find more information about borrowing in the rust-book:\nhttp://doc.rust-lang.org/stable/book/references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":612,"byte_end":615,"line_start":19,"line_end":19,"column_start":14,"column_end":17,"is_primary":false,"text":[{"text":"    let p1 = &x1;","highlight_start":14,"highlight_end":17}],"label":"borrow of `x1` occurs here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":681,"byte_end":857,"line_start":22,"line_end":25,"column_start":19,"column_end":6,"is_primary":true,"text":[{"text":"    thread::spawn(move|| {","highlight_start":19,"highlight_end":27},{"text":"        drop(x1); //~ ERROR cannot move `x1` into closure because it is borrowed","highlight_start":1,"highlight_end":81},{"text":"        drop(x2); //~ ERROR cannot move `x2` into closure because it is borrowed","highlight_start":1,"highlight_end":81},{"text":"    });","highlight_start":1,"highlight_end":6}],"label":"move out of `x1` occurs here","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"cannot move out of `x2` because it is borrowed (Mir)","code":{"code":"E0505","explanation":"\nA value was moved out while it was still borrowed.\n\nErroneous code example:\n\n```compile_fail,E0505\nstruct Value {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    {\n        let _ref_to_val: &Value = &x;\n        eat(x);\n    }\n}\n```\n\nHere, the function `eat` takes the ownership of `x`. However,\n`x` cannot be moved because it was borrowed to `_ref_to_val`.\nTo fix that you can do few different things:\n\n* Try to avoid moving the variable.\n* Release borrow before move.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nstruct Value {}\n\nfn eat(val: &Value) {}\n\nfn main() {\n    let x = Value{};\n    {\n        let _ref_to_val: &Value = &x;\n        eat(&x); // pass by reference, if it's possible\n    }\n}\n```\n\nOr:\n\n```\nstruct Value {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    {\n        let _ref_to_val: &Value = &x;\n    }\n    eat(x); // release borrow and then move it.\n}\n```\n\nOr:\n\n```\n#[derive(Clone, Copy)] // implement Copy trait\nstruct Value {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    {\n        let _ref_to_val: &Value = &x;\n        eat(x); // it will be copied here.\n    }\n}\n```\n\nYou can find more information about borrowing in the rust-book:\nhttp://doc.rust-lang.org/stable/book/references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":658,"byte_end":661,"line_start":21,"line_end":21,"column_start":14,"column_end":17,"is_primary":false,"text":[{"text":"    let p2 = &x2;","highlight_start":14,"highlight_end":17}],"label":"borrow of `x2` occurs here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":681,"byte_end":857,"line_start":22,"line_end":25,"column_start":19,"column_end":6,"is_primary":true,"text":[{"text":"    thread::spawn(move|| {","highlight_start":19,"highlight_end":27},{"text":"        drop(x1); //~ ERROR cannot move `x1` into closure because it is borrowed","highlight_start":1,"highlight_end":81},{"text":"        drop(x2); //~ ERROR cannot move `x2` into closure because it is borrowed","highlight_start":1,"highlight_end":81},{"text":"    });","highlight_start":1,"highlight_end":6}],"label":"move out of `x2` occurs here","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"use of possibly uninitialized variable: `x1` (Mir)","code":{"code":"E0381","explanation":"\nIt is not allowed to use or capture an uninitialized variable. For example:\n\n```compile_fail,E0381\nfn main() {\n    let x: i32;\n    let y = x; // error, use of possibly uninitialized variable\n}\n```\n\nTo fix this, ensure that any declared variables are initialized before being\nused. Example:\n\n```\nfn main() {\n    let x: i32 = 0;\n    let y = x; // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1035,"byte_end":1163,"line_start":35,"line_end":38,"column_start":19,"column_end":6,"is_primary":true,"text":[{"text":"    thread::spawn(move|| {","highlight_start":19,"highlight_end":27},{"text":"        drop(x1); //~ ERROR capture of moved value: `x1`","highlight_start":1,"highlight_end":57},{"text":"        drop(x2); //~ ERROR capture of moved value: `x2`","highlight_start":1,"highlight_end":57},{"text":"    });","highlight_start":1,"highlight_end":6}],"label":"use of possibly uninitialized `x1`","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"use of possibly uninitialized variable: `x2` (Mir)","code":{"code":"E0381","explanation":"\nIt is not allowed to use or capture an uninitialized variable. For example:\n\n```compile_fail,E0381\nfn main() {\n    let x: i32;\n    let y = x; // error, use of possibly uninitialized variable\n}\n```\n\nTo fix this, ensure that any declared variables are initialized before being\nused. Example:\n\n```\nfn main() {\n    let x: i32 = 0;\n    let y = x; // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1035,"byte_end":1163,"line_start":35,"line_end":38,"column_start":19,"column_end":6,"is_primary":true,"text":[{"text":"    thread::spawn(move|| {","highlight_start":19,"highlight_end":27},{"text":"        drop(x1); //~ ERROR capture of moved value: `x1`","highlight_start":1,"highlight_end":57},{"text":"        drop(x2); //~ ERROR capture of moved value: `x2`","highlight_start":1,"highlight_end":57},{"text":"    });","highlight_start":1,"highlight_end":6}],"label":"use of possibly uninitialized `x2`","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"cannot move out of `x` because it is borrowed (Mir)","code":{"code":"E0505","explanation":"\nA value was moved out while it was still borrowed.\n\nErroneous code example:\n\n```compile_fail,E0505\nstruct Value {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    {\n        let _ref_to_val: &Value = &x;\n        eat(x);\n    }\n}\n```\n\nHere, the function `eat` takes the ownership of `x`. However,\n`x` cannot be moved because it was borrowed to `_ref_to_val`.\nTo fix that you can do few different things:\n\n* Try to avoid moving the variable.\n* Release borrow before move.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nstruct Value {}\n\nfn eat(val: &Value) {}\n\nfn main() {\n    let x = Value{};\n    {\n        let _ref_to_val: &Value = &x;\n        eat(&x); // pass by reference, if it's possible\n    }\n}\n```\n\nOr:\n\n```\nstruct Value {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    {\n        let _ref_to_val: &Value = &x;\n    }\n    eat(x); // release borrow and then move it.\n}\n```\n\nOr:\n\n```\n#[derive(Clone, Copy)] // implement Copy trait\nstruct Value {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    {\n        let _ref_to_val: &Value = &x;\n        eat(x); // it will be copied here.\n    }\n}\n```\n\nYou can find more information about borrowing in the rust-book:\nhttp://doc.rust-lang.org/stable/book/references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1237,"byte_end":1239,"line_start":43,"line_end":43,"column_start":13,"column_end":15,"is_primary":false,"text":[{"text":"    let p = &x;","highlight_start":13,"highlight_end":15}],"label":"borrow of `x` occurs here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1259,"byte_end":1403,"line_start":44,"line_end":47,"column_start":19,"column_end":6,"is_primary":true,"text":[{"text":"    thread::spawn(move|| {","highlight_start":19,"highlight_end":27},{"text":"        drop(x); //~ ERROR cannot move `x` into closure because it is borrowed","highlight_start":1,"highlight_end":79},{"text":"        drop(x); //~ ERROR use of moved value: `x`","highlight_start":1,"highlight_end":51},{"text":"    });","highlight_start":1,"highlight_end":6}],"label":"move out of `x` occurs here","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"use of moved value: `x` (Mir)","code":{"code":"E0382","explanation":"\nThis error occurs when an attempt is made to use a variable after its contents\nhave been moved elsewhere. For example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`.  Implicit\ncloning is more convienient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the chapter in the\nBook:\n\nhttps://doc.rust-lang.org/book/first-edition/ownership.html\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1360,"byte_end":1361,"line_start":46,"line_end":46,"column_start":14,"column_end":15,"is_primary":true,"text":[{"text":"        drop(x); //~ ERROR use of moved value: `x`","highlight_start":14,"highlight_end":15}],"label":"value use here after move","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1281,"byte_end":1282,"line_start":45,"line_end":45,"column_start":14,"column_end":15,"is_primary":false,"text":[{"text":"        drop(x); //~ ERROR cannot move `x` into closure because it is borrowed","highlight_start":14,"highlight_end":15}],"label":"value moved here","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"use of possibly uninitialized variable: `x` (Mir)","code":{"code":"E0381","explanation":"\nIt is not allowed to use or capture an uninitialized variable. For example:\n\n```compile_fail,E0381\nfn main() {\n    let x: i32;\n    let y = x; // error, use of possibly uninitialized variable\n}\n```\n\nTo fix this, ensure that any declared variables are initialized before being\nused. Example:\n\n```\nfn main() {\n    let x: i32 = 0;\n    let y = x; // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1511,"byte_end":1631,"line_start":54,"line_end":57,"column_start":19,"column_end":6,"is_primary":true,"text":[{"text":"    thread::spawn(move|| {","highlight_start":19,"highlight_end":27},{"text":"        drop(x); //~ ERROR capture of moved value: `x`","highlight_start":1,"highlight_end":55},{"text":"        drop(x); //~ ERROR use of moved value: `x`","highlight_start":1,"highlight_end":51},{"text":"    });","highlight_start":1,"highlight_end":6}],"label":"use of possibly uninitialized `x`","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"use of moved value: `x` (Mir)","code":{"code":"E0382","explanation":"\nThis error occurs when an attempt is made to use a variable after its contents\nhave been moved elsewhere. For example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`.  Implicit\ncloning is more convienient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the chapter in the\nBook:\n\nhttps://doc.rust-lang.org/book/first-edition/ownership.html\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1588,"byte_end":1589,"line_start":56,"line_end":56,"column_start":14,"column_end":15,"is_primary":true,"text":[{"text":"        drop(x); //~ ERROR use of moved value: `x`","highlight_start":14,"highlight_end":15}],"label":"value use here after move","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/borrowck/borrowck-multiple-captures.rs","byte_start":1533,"byte_end":1534,"line_start":55,"line_end":55,"column_start":14,"column_end":15,"is_primary":false,"text":[{"text":"        drop(x); //~ ERROR capture of moved value: `x`","highlight_start":14,"highlight_end":15}],"label":"value moved here","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"aborting due to 16 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":null}
