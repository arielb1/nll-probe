{"message":"cannot move a value of type X: the size of X cannot be statically determined","code":{"code":"E0161","explanation":"\nA value was moved. However, its size was not known at compile time, and only\nvalues of a known size can be moved.\n\nErroneous code example:\n\n```compile_fail\n#![feature(box_syntax)]\n\nfn main() {\n    let array: &[isize] = &[1, 2, 3];\n    let _x: Box<[isize]> = box *array;\n    // error: cannot move a value of type [isize]: the size of [isize] cannot\n    //        be statically determined\n}\n```\n\nIn Rust, you can only move a value when its size is known at compile time.\n\nTo work around this restriction, consider \"hiding\" the value behind a reference:\neither `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\nit around as usual. Example:\n\n```\n#![feature(box_syntax)]\n\nfn main() {\n    let array: &[isize] = &[1, 2, 3];\n    let _x: Box<&[isize]> = box array; // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/issue-30355.rs","byte_start":556,"byte_end":561,"line_start":15,"line_end":15,"column_start":6,"column_end":11,"is_primary":true,"text":[{"text":"    &X(*Y)","highlight_start":6,"highlight_end":11}],"label":null,"suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"cannot move a value of type [u8]: the size of [u8] cannot be statically determined","code":{"code":"E0161","explanation":"\nA value was moved. However, its size was not known at compile time, and only\nvalues of a known size can be moved.\n\nErroneous code example:\n\n```compile_fail\n#![feature(box_syntax)]\n\nfn main() {\n    let array: &[isize] = &[1, 2, 3];\n    let _x: Box<[isize]> = box *array;\n    // error: cannot move a value of type [isize]: the size of [isize] cannot\n    //        be statically determined\n}\n```\n\nIn Rust, you can only move a value when its size is known at compile time.\n\nTo work around this restriction, consider \"hiding\" the value behind a reference:\neither `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\nit around as usual. Example:\n\n```\n#![feature(box_syntax)]\n\nfn main() {\n    let array: &[isize] = &[1, 2, 3];\n    let _x: Box<&[isize]> = box array; // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/issue-30355.rs","byte_start":558,"byte_end":560,"line_start":15,"line_end":15,"column_start":8,"column_end":10,"is_primary":true,"text":[{"text":"    &X(*Y)","highlight_start":8,"highlight_end":10}],"label":null,"suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"cannot move out of borrowed content (Ast)","code":{"code":"E0507","explanation":"\nYou tried to move out of a value which was borrowed. Erroneous code example:\n\n```compile_fail,E0507\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n}\n```\n\nHere, the `nothing_is_true` method takes the ownership of `self`. However,\n`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\nwhich is a borrow of the content owned by the `RefCell`. To fix this error,\nyou have three choices:\n\n* Try to avoid moving the variable.\n* Somehow reclaim the ownership.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(&self) {} // First case, we don't take ownership\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n    let x = x.into_inner(); // we get back ownership\n\n    x.nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\n#[derive(Clone, Copy)] // we implement the Copy trait\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nMoving a member out of a mutably borrowed struct will also cause E0507 error:\n\n```compile_fail,E0507\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nstruct Batcave {\n    knight: TheDarkKnight\n}\n\nfn main() {\n    let mut cave = Batcave {\n        knight: TheDarkKnight\n    };\n    let borrowed = &mut cave;\n\n    borrowed.knight.nothing_is_true(); // E0507\n}\n```\n\nIt is fine only if you put something back. `mem::replace` can be used for that:\n\n```\n# struct TheDarkKnight;\n# impl TheDarkKnight { fn nothing_is_true(self) {} }\n# struct Batcave { knight: TheDarkKnight }\nuse std::mem;\n\nlet mut cave = Batcave {\n    knight: TheDarkKnight\n};\nlet borrowed = &mut cave;\n\nmem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n```\n\nYou can find more information about borrowing in the rust-book:\nhttp://doc.rust-lang.org/book/first-edition/references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/issue-30355.rs","byte_start":558,"byte_end":560,"line_start":15,"line_end":15,"column_start":8,"column_end":10,"is_primary":true,"text":[{"text":"    &X(*Y)","highlight_start":8,"highlight_end":10}],"label":"cannot move out of borrowed content","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"cannot move out of borrowed_content (Mir)","code":{"code":"E0507","explanation":"\nYou tried to move out of a value which was borrowed. Erroneous code example:\n\n```compile_fail,E0507\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n}\n```\n\nHere, the `nothing_is_true` method takes the ownership of `self`. However,\n`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\nwhich is a borrow of the content owned by the `RefCell`. To fix this error,\nyou have three choices:\n\n* Try to avoid moving the variable.\n* Somehow reclaim the ownership.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(&self) {} // First case, we don't take ownership\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n    let x = x.into_inner(); // we get back ownership\n\n    x.nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\n#[derive(Clone, Copy)] // we implement the Copy trait\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nMoving a member out of a mutably borrowed struct will also cause E0507 error:\n\n```compile_fail,E0507\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nstruct Batcave {\n    knight: TheDarkKnight\n}\n\nfn main() {\n    let mut cave = Batcave {\n        knight: TheDarkKnight\n    };\n    let borrowed = &mut cave;\n\n    borrowed.knight.nothing_is_true(); // E0507\n}\n```\n\nIt is fine only if you put something back. `mem::replace` can be used for that:\n\n```\n# struct TheDarkKnight;\n# impl TheDarkKnight { fn nothing_is_true(self) {} }\n# struct Batcave { knight: TheDarkKnight }\nuse std::mem;\n\nlet mut cave = Batcave {\n    knight: TheDarkKnight\n};\nlet borrowed = &mut cave;\n\nmem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n```\n\nYou can find more information about borrowing in the rust-book:\nhttp://doc.rust-lang.org/book/first-edition/references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/issue-30355.rs","byte_start":558,"byte_end":560,"line_start":15,"line_end":15,"column_start":8,"column_end":10,"is_primary":true,"text":[{"text":"    &X(*Y)","highlight_start":8,"highlight_end":10}],"label":"cannot move out of borrowed_content","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"aborting due to 4 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":null}
