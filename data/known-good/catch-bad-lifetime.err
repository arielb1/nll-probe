{"message":"borrowed value does not live long enough","code":{"code":"E0597","explanation":"\nThis error occurs because a borrow was made inside a variable which has a\ngreater lifetime than the borrowed one.\n\nExample of erroneous code:\n\n```compile_fail,E0597\nstruct Foo<'a> {\n    x: Option<&'a u32>,\n}\n\nlet mut x = Foo { x: None };\nlet y = 0;\nx.x = Some(&y); // error: `y` does not live long enough\n```\n\nIn here, `x` is created before `y` and therefore has a greater lifetime. Always\nkeep in mind that values in a scope are dropped in the opposite order they are\ncreated. So to fix the previous example, just make the `y` lifetime greater than\nthe `x`'s one:\n\n```\nstruct Foo<'a> {\n    x: Option<&'a u32>,\n}\n\nlet y = 0;\nlet mut x = Foo { x: None };\nx.x = Some(&y);\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/catch-bad-lifetime.rs","byte_start":799,"byte_end":808,"line_start":19,"line_end":19,"column_start":17,"column_end":26,"is_primary":false,"text":[{"text":"            let my_string = String::from(\"\");","highlight_start":17,"highlight_end":26}],"label":"temporary value created here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/catch-bad-lifetime.rs","byte_start":952,"byte_end":952,"line_start":24,"line_end":24,"column_start":10,"column_end":10,"is_primary":true,"text":[{"text":"        }; //~ ERROR `my_string` does not live long enough","highlight_start":10,"highlight_end":10}],"label":"temporary value dropped here while still borrowed","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/catch-bad-lifetime.rs","byte_start":1006,"byte_end":1007,"line_start":25,"line_end":25,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    }","highlight_start":5,"highlight_end":6}],"label":"temporary value needs to live until here","suggested_replacement":null,"expansion":null}],"children":[{"message":"consider using a `let` binding to increase its lifetime","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"error[E0597]: borrowed value does not live long enough\n  --> /home/ariel/Rust/rust-master/src/test/compile-fail/catch-bad-lifetime.rs:24:10\n   |\n19 |             let my_string = String::from(\"\");\n   |                 --------- temporary value created here\n...\n24 |         }; //~ ERROR `my_string` does not live long enough\n   |          ^ temporary value dropped here while still borrowed\n25 |     }\n   |     - temporary value needs to live until here\n   |\n   = note: consider using a `let` binding to increase its lifetime\n\n"}
{"message":"use of moved value: `k`","code":{"code":"E0382","explanation":"\nThis error occurs when an attempt is made to use a variable after its contents\nhave been moved elsewhere. For example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`.  Implicit\ncloning is more convienient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the chapter in the\nBook:\n\nhttps://doc.rust-lang.org/book/first-edition/ownership.html\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/catch-bad-lifetime.rs","byte_start":1344,"byte_end":1345,"line_start":36,"line_end":36,"column_start":26,"column_end":27,"is_primary":true,"text":[{"text":"        ::std::mem::drop(k); //~ ERROR use of moved value: `k`","highlight_start":26,"highlight_end":27}],"label":"value used here after move","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/catch-bad-lifetime.rs","byte_start":1209,"byte_end":1210,"line_start":32,"line_end":32,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"            Err(k) ?;","highlight_start":17,"highlight_end":18}],"label":"value moved here","suggested_replacement":null,"expansion":null}],"children":[],"rendered":"error[E0382]: use of moved value: `k`\n  --> /home/ariel/Rust/rust-master/src/test/compile-fail/catch-bad-lifetime.rs:36:26\n   |\n32 |             Err(k) ?;\n   |                 - value moved here\n...\n36 |         ::std::mem::drop(k); //~ ERROR use of moved value: `k`\n   |                          ^ value used here after move\n\n"}
{"message":"cannot assign to `i` because it is borrowed","code":{"code":"E0506","explanation":"\nThis error occurs when an attempt is made to assign to a borrowed value.\n\nExample of erroneous code:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy_num = FancyNum { num: 5 };\n    let fancy_ref = &fancy_num;\n    fancy_num = FancyNum { num: 6 };\n    // error: cannot assign to `fancy_num` because it is borrowed\n\n    println!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n}\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy_num = FancyNum { num: 5 };\n    let moved_num = fancy_num;\n    fancy_num = FancyNum { num: 6 };\n\n    println!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n}\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy_num = FancyNum { num: 5 };\n\n    {\n        let fancy_ref = &fancy_num;\n        println!(\"Ref: {}\", fancy_ref.num);\n    }\n\n    // Works because `fancy_ref` is no longer in scope\n    fancy_num = FancyNum { num: 6 };\n    println!(\"Num: {}\", fancy_num.num);\n}\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy_num = FancyNum { num: 5 };\n\n    print_fancy_ref(&fancy_num);\n\n    // Works because function borrow has ended\n    fancy_num = FancyNum { num: 6 };\n    println!(\"Num: {}\", fancy_num.num);\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/catch-bad-lifetime.rs","byte_start":1132,"byte_end":1138,"line_start":30,"line_end":30,"column_start":17,"column_end":23,"is_primary":false,"text":[{"text":"        let k = &mut i;","highlight_start":17,"highlight_end":23}],"label":"borrow of `i` occurs here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/catch-bad-lifetime.rs","byte_start":1227,"byte_end":1233,"line_start":33,"line_end":33,"column_start":13,"column_end":19,"is_primary":true,"text":[{"text":"            i = 10; //~ ERROR cannot assign to `i` because it is borrowed","highlight_start":13,"highlight_end":19}],"label":"assignment to borrowed `i` occurs here","suggested_replacement":null,"expansion":null}],"children":[],"rendered":"error[E0506]: cannot assign to `i` because it is borrowed\n  --> /home/ariel/Rust/rust-master/src/test/compile-fail/catch-bad-lifetime.rs:33:13\n   |\n30 |         let k = &mut i;\n   |                 ------ borrow of `i` occurs here\n...\n33 |             i = 10; //~ ERROR cannot assign to `i` because it is borrowed\n   |             ^^^^^^ assignment to borrowed `i` occurs here\n\n"}
{"message":"cannot assign to `i` because it is borrowed","code":{"code":"E0506","explanation":"\nThis error occurs when an attempt is made to assign to a borrowed value.\n\nExample of erroneous code:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy_num = FancyNum { num: 5 };\n    let fancy_ref = &fancy_num;\n    fancy_num = FancyNum { num: 6 };\n    // error: cannot assign to `fancy_num` because it is borrowed\n\n    println!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n}\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy_num = FancyNum { num: 5 };\n    let moved_num = fancy_num;\n    fancy_num = FancyNum { num: 6 };\n\n    println!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n}\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy_num = FancyNum { num: 5 };\n\n    {\n        let fancy_ref = &fancy_num;\n        println!(\"Ref: {}\", fancy_ref.num);\n    }\n\n    // Works because `fancy_ref` is no longer in scope\n    fancy_num = FancyNum { num: 6 };\n    println!(\"Num: {}\", fancy_num.num);\n}\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy_num = FancyNum { num: 5 };\n\n    print_fancy_ref(&fancy_num);\n\n    // Works because function borrow has ended\n    fancy_num = FancyNum { num: 6 };\n    println!(\"Num: {}\", fancy_num.num);\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/catch-bad-lifetime.rs","byte_start":1132,"byte_end":1138,"line_start":30,"line_end":30,"column_start":17,"column_end":23,"is_primary":false,"text":[{"text":"        let k = &mut i;","highlight_start":17,"highlight_end":23}],"label":"borrow of `i` occurs here","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-master/src/test/compile-fail/catch-bad-lifetime.rs","byte_start":1390,"byte_end":1396,"line_start":37,"line_end":37,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        i = 40; //~ ERROR cannot assign to `i` because it is borrowed","highlight_start":9,"highlight_end":15}],"label":"assignment to borrowed `i` occurs here","suggested_replacement":null,"expansion":null}],"children":[],"rendered":"error[E0506]: cannot assign to `i` because it is borrowed\n  --> /home/ariel/Rust/rust-master/src/test/compile-fail/catch-bad-lifetime.rs:37:9\n   |\n30 |         let k = &mut i;\n   |                 ------ borrow of `i` occurs here\n...\n37 |         i = 40; //~ ERROR cannot assign to `i` because it is borrowed\n   |         ^^^^^^ assignment to borrowed `i` occurs here\n\n"}
{"message":"aborting due to 4 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"error: aborting due to 4 previous errors\n\n"}
