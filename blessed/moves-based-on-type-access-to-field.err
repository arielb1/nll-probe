{"message":"use of moved value: `x` (Ast)","code":{"code":"E0382","explanation":"\nThis error occurs when an attempt is made to use a variable after its contents\nhave been moved elsewhere. For example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nIf we own the type, the easiest way to address this problem is to implement\n`Copy` and `Clone` on it, as shown below. This allows `y` to copy the\ninformation in `x`, while leaving the original version owned by `x`. Subsequent\nchanges to `x` will not be reflected when accessing `y`.\n\n```\n#[derive(Copy, Clone)]\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the chapter in the\nBook:\n\nhttps://doc.rust-lang.org/book/first-edition/ownership.html\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-emergency/src/test/compile-fail/moves-based-on-type-access-to-field.rs","byte_start":782,"byte_end":783,"line_start":21,"line_end":21,"column_start":12,"column_end":13,"is_primary":true,"text":[{"text":"    touch(&x[0]); //~ ERROR use of moved value: `x`","highlight_start":12,"highlight_end":13}],"label":"value used here after move","suggested_replacement":null,"expansion":null},{"file_name":"/home/ariel/Rust/rust-emergency/src/test/compile-fail/moves-based-on-type-access-to-field.rs","byte_start":739,"byte_end":740,"line_start":20,"line_end":20,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"    consume(x.into_iter().next().unwrap());","highlight_start":13,"highlight_end":14}],"label":"value moved here","suggested_replacement":null,"expansion":null}],"children":[{"message":"move occurs because `x` has type `std::vec::Vec<std::string::String>`, which does not implement the `Copy` trait","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":null}
{"message":"borrow of possibly uninitialized variable: `x` (Mir)","code":{"code":"E0381","explanation":"\nIt is not allowed to use or capture an uninitialized variable. For example:\n\n```compile_fail,E0381\nfn main() {\n    let x: i32;\n    let y = x; // error, use of possibly uninitialized variable\n}\n```\n\nTo fix this, ensure that any declared variables are initialized before being\nused. Example:\n\n```\nfn main() {\n    let x: i32 = 0;\n    let y = x; // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/ariel/Rust/rust-emergency/src/test/compile-fail/moves-based-on-type-access-to-field.rs","byte_start":782,"byte_end":783,"line_start":21,"line_end":21,"column_start":12,"column_end":13,"is_primary":true,"text":[{"text":"    touch(&x[0]); //~ ERROR use of moved value: `x`","highlight_start":12,"highlight_end":13}],"label":"use of possibly uninitialized `x`","suggested_replacement":null,"expansion":null}],"children":[],"rendered":null}
{"message":"aborting due to 2 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":null}
